'use strict';

var _Map = require('babel-runtime/core-js/map')['default'];

var _getIterator = require('babel-runtime/core-js/get-iterator')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

var _coreGetExports = require('../core/getExports');

var _coreGetExports2 = _interopRequireDefault(_coreGetExports);

var _importDeclaration = require('../importDeclaration');

var _importDeclaration2 = _interopRequireDefault(_importDeclaration);

module.exports = function (context) {

  var namespaces = new _Map();

  function getImportsAndReport(namespace) {
    var declaration = (0, _importDeclaration2['default'])(context);

    var imports = _coreGetExports2['default'].get(declaration.source.value, context);
    if (imports == null) return null;

    if (imports.errors.length) {
      context.report({
        node: declaration.source,
        message: 'Parse errors in imported module ' + ('\'' + declaration.source.value + '\'.')
      });
      return;
    }

    if (!imports.hasNamed) {
      context.report(namespace, 'No exported names found in module \'' + declaration.source.value + '\'.');
    }

    return imports;
  }

  function message(identifier, namespace) {
    return '\'' + identifier.name + '\' not found in imported namespace ' + namespace.name + '.';
  }

  function declaredScope(name) {
    var references = context.getScope().references,
        i = undefined;
    for (i = 0; i < references.length; i++) {
      if (references[i].identifier.name === name) {
        break;
      }
    }
    if (!references[i]) return undefined;
    return references[i].resolved.scope.type;
  }

  return {
    'ImportNamespaceSpecifier': function ImportNamespaceSpecifier(namespace) {
      var imports = getImportsAndReport(namespace);
      if (imports == null) return;
      namespaces.set(namespace.local.name, imports.named);
    },

    // same as above, but does not add names to local map
    'ExportNamespaceSpecifier': function ExportNamespaceSpecifier(namespace) {
      getImportsAndReport(namespace);
    },

    // todo: check for possible redefinition

    'MemberExpression': function MemberExpression(dereference) {
      if (dereference.object.type !== 'Identifier') return;
      if (!namespaces.has(dereference.object.name)) return;

      if (dereference.parent.type === 'AssignmentExpression' && dereference.parent.left === dereference) {
        context.report(dereference.parent, 'Assignment to member of namespace \'' + dereference.object.name + '\'.');
      }

      if (dereference.computed) {
        context.report(dereference.property, 'Unable to validate computed reference to imported namespace \'' + dereference.object.name + '\'.');
        return;
      }

      var namespace = namespaces.get(dereference.object.name);
      if (!namespace.has(dereference.property.name)) {
        context.report(dereference.property, message(dereference.property, dereference.object));
      }
    },

    'VariableDeclarator': function VariableDeclarator(_ref) {
      var id = _ref.id;
      var init = _ref.init;

      if (init == null) return;
      if (id.type !== 'ObjectPattern') return;
      if (init.type !== 'Identifier') return;
      if (!namespaces.has(init.name)) return;

      // check for redefinition in intermediate scopes
      if (declaredScope(init.name) !== 'module') return;

      var namespace = namespaces.get(init.name);

      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = _getIterator(id.properties), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var property = _step.value;

          if (property.key.type !== 'Identifier') {
            context.report({
              node: property,
              message: 'Only destructure top-level names.'
            });
          } else if (!namespace.has(property.key.name)) {
            context.report({
              node: property,
              message: message(property.key, init)
            });
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator['return']) {
            _iterator['return']();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    }
  };
};
//# sourceMappingURL=data:application/json;base64,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QUksQ0FBQyxDQUFBOzs7Ozs7O0FBRTNDLDBDQUFxQixFQUFFLENBQUMsVUFBVSw0R0FBRTtjQUEzQixRQUFROztBQUNmLGNBQUksUUFBUSxDQUFDLEdBQUcsQ0FBQyxJQUFJLEtBQUssWUFBWSxFQUFFO0FBQ3RDLG1CQUFPLENBQUMsTUFBTSxDQUFDO0FBQ2Isa0JBQUksRUFBRSxRQUFRO0FBQ2QscUJBQU8sRUFBRSxtQ0FBbUM7YUFDN0MsQ0FBQyxDQUFBO1dBQ0gsTUFBTSxJQUFJLENBQUMsU0FBUyxDQUFDLEdBQUcsQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxFQUFFO0FBQzVDLG1CQUFPLENBQUMsTUFBTSxDQUFDO0FBQ2Isa0JBQUksRUFBRSxRQUFRO0FBQ2QscUJBQU8sRUFBRSxPQUFPLENBQUMsUUFBUSxDQUFDLEdBQUcsRUFBRSxJQUFJLENBQUM7YUFDckMsQ0FBQyxDQUFBO1dBQ0g7U0FDRjs7Ozs7Ozs7Ozs7Ozs7O0tBQ0Y7R0FDRixDQUFBO0NBQ0YsQ0FBQSIsImZpbGUiOiJydWxlcy9uYW1lc3BhY2UuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgRXhwb3J0cyBmcm9tICcuLi9jb3JlL2dldEV4cG9ydHMnXG5pbXBvcnQgaW1wb3J0RGVjbGFyYXRpb24gZnJvbSAnLi4vaW1wb3J0RGVjbGFyYXRpb24nXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcblxuICBjb25zdCBuYW1lc3BhY2VzID0gbmV3IE1hcCgpXG5cbiAgZnVuY3Rpb24gZ2V0SW1wb3J0c0FuZFJlcG9ydChuYW1lc3BhY2UpIHtcbiAgICB2YXIgZGVjbGFyYXRpb24gPSBpbXBvcnREZWNsYXJhdGlvbihjb250ZXh0KVxuXG4gICAgdmFyIGltcG9ydHMgPSBFeHBvcnRzLmdldChkZWNsYXJhdGlvbi5zb3VyY2UudmFsdWUsIGNvbnRleHQpXG4gICAgaWYgKGltcG9ydHMgPT0gbnVsbCkgcmV0dXJuIG51bGxcblxuICAgIGlmIChpbXBvcnRzLmVycm9ycy5sZW5ndGgpIHtcbiAgICAgIGNvbnRleHQucmVwb3J0KHtcbiAgICAgICAgbm9kZTogZGVjbGFyYXRpb24uc291cmNlLFxuICAgICAgICBtZXNzYWdlOiBgUGFyc2UgZXJyb3JzIGluIGltcG9ydGVkIG1vZHVsZSBgICtcbiAgICAgICAgICAgICAgICAgYCcke2RlY2xhcmF0aW9uLnNvdXJjZS52YWx1ZX0nLmAsXG4gICAgICB9KVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKCFpbXBvcnRzLmhhc05hbWVkKSB7XG4gICAgICBjb250ZXh0LnJlcG9ydChuYW1lc3BhY2UsXG4gICAgICAgIGBObyBleHBvcnRlZCBuYW1lcyBmb3VuZCBpbiBtb2R1bGUgJyR7ZGVjbGFyYXRpb24uc291cmNlLnZhbHVlfScuYClcbiAgICB9XG5cbiAgICByZXR1cm4gaW1wb3J0c1xuICB9XG5cbiAgZnVuY3Rpb24gbWVzc2FnZShpZGVudGlmaWVyLCBuYW1lc3BhY2UpIHtcbiAgICByZXR1cm4gJ1xcJycgKyBpZGVudGlmaWVyLm5hbWUgK1xuICAgICAgICAgICAnXFwnIG5vdCBmb3VuZCBpbiBpbXBvcnRlZCBuYW1lc3BhY2UgJyArXG4gICAgICAgICAgIG5hbWVzcGFjZS5uYW1lICsgJy4nXG4gIH1cblxuICBmdW5jdGlvbiBkZWNsYXJlZFNjb3BlKG5hbWUpIHtcbiAgICBsZXQgcmVmZXJlbmNlcyA9IGNvbnRleHQuZ2V0U2NvcGUoKS5yZWZlcmVuY2VzXG4gICAgICAsIGlcbiAgICBmb3IgKGkgPSAwOyBpIDwgcmVmZXJlbmNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHJlZmVyZW5jZXNbaV0uaWRlbnRpZmllci5uYW1lID09PSBuYW1lKSB7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuICAgIGlmICghcmVmZXJlbmNlc1tpXSkgcmV0dXJuIHVuZGVmaW5lZFxuICAgIHJldHVybiByZWZlcmVuY2VzW2ldLnJlc29sdmVkLnNjb3BlLnR5cGVcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgJ0ltcG9ydE5hbWVzcGFjZVNwZWNpZmllcic6IGZ1bmN0aW9uIChuYW1lc3BhY2UpIHtcbiAgICAgIGNvbnN0IGltcG9ydHMgPSBnZXRJbXBvcnRzQW5kUmVwb3J0KG5hbWVzcGFjZSlcbiAgICAgIGlmIChpbXBvcnRzID09IG51bGwpIHJldHVyblxuICAgICAgbmFtZXNwYWNlcy5zZXQobmFtZXNwYWNlLmxvY2FsLm5hbWUsIGltcG9ydHMubmFtZWQpXG4gICAgfSxcblxuICAgIC8vIHNhbWUgYXMgYWJvdmUsIGJ1dCBkb2VzIG5vdCBhZGQgbmFtZXMgdG8gbG9jYWwgbWFwXG4gICAgJ0V4cG9ydE5hbWVzcGFjZVNwZWNpZmllcic6IGZ1bmN0aW9uIChuYW1lc3BhY2UpIHtcbiAgICAgIGdldEltcG9ydHNBbmRSZXBvcnQobmFtZXNwYWNlKVxuICAgIH0sXG5cbiAgICAvLyB0b2RvOiBjaGVjayBmb3IgcG9zc2libGUgcmVkZWZpbml0aW9uXG5cbiAgICAnTWVtYmVyRXhwcmVzc2lvbic6IGZ1bmN0aW9uIChkZXJlZmVyZW5jZSkge1xuICAgICAgaWYgKGRlcmVmZXJlbmNlLm9iamVjdC50eXBlICE9PSAnSWRlbnRpZmllcicpIHJldHVyblxuICAgICAgaWYgKCFuYW1lc3BhY2VzLmhhcyhkZXJlZmVyZW5jZS5vYmplY3QubmFtZSkpIHJldHVyblxuXG4gICAgICBpZiAoZGVyZWZlcmVuY2UucGFyZW50LnR5cGUgPT09ICdBc3NpZ25tZW50RXhwcmVzc2lvbicgJiZcbiAgICAgICAgICBkZXJlZmVyZW5jZS5wYXJlbnQubGVmdCA9PT0gZGVyZWZlcmVuY2UpIHtcbiAgICAgICAgICBjb250ZXh0LnJlcG9ydChkZXJlZmVyZW5jZS5wYXJlbnQsXG4gICAgICAgICAgICAgIGBBc3NpZ25tZW50IHRvIG1lbWJlciBvZiBuYW1lc3BhY2UgJyR7ZGVyZWZlcmVuY2Uub2JqZWN0Lm5hbWV9Jy5gKVxuICAgICAgfVxuXG4gICAgICBpZiAoZGVyZWZlcmVuY2UuY29tcHV0ZWQpIHtcbiAgICAgICAgY29udGV4dC5yZXBvcnQoZGVyZWZlcmVuY2UucHJvcGVydHksXG4gICAgICAgICAgJ1VuYWJsZSB0byB2YWxpZGF0ZSBjb21wdXRlZCByZWZlcmVuY2UgdG8gaW1wb3J0ZWQgbmFtZXNwYWNlIFxcJycgK1xuICAgICAgICAgIGRlcmVmZXJlbmNlLm9iamVjdC5uYW1lICsgJ1xcJy4nKVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgdmFyIG5hbWVzcGFjZSA9IG5hbWVzcGFjZXMuZ2V0KGRlcmVmZXJlbmNlLm9iamVjdC5uYW1lKVxuICAgICAgaWYgKCFuYW1lc3BhY2UuaGFzKGRlcmVmZXJlbmNlLnByb3BlcnR5Lm5hbWUpKSB7XG4gICAgICAgIGNvbnRleHQucmVwb3J0KCBkZXJlZmVyZW5jZS5wcm9wZXJ0eVxuICAgICAgICAgICAgICAgICAgICAgICwgbWVzc2FnZShkZXJlZmVyZW5jZS5wcm9wZXJ0eSwgZGVyZWZlcmVuY2Uub2JqZWN0KVxuICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgJ1ZhcmlhYmxlRGVjbGFyYXRvcic6IGZ1bmN0aW9uICh7IGlkLCBpbml0IH0pIHtcbiAgICAgIGlmIChpbml0ID09IG51bGwpIHJldHVyblxuICAgICAgaWYgKGlkLnR5cGUgIT09ICdPYmplY3RQYXR0ZXJuJykgcmV0dXJuXG4gICAgICBpZiAoaW5pdC50eXBlICE9PSAnSWRlbnRpZmllcicpIHJldHVyblxuICAgICAgaWYgKCFuYW1lc3BhY2VzLmhhcyhpbml0Lm5hbWUpKSByZXR1cm5cblxuICAgICAgLy8gY2hlY2sgZm9yIHJlZGVmaW5pdGlvbiBpbiBpbnRlcm1lZGlhdGUgc2NvcGVzXG4gICAgICBpZiAoZGVjbGFyZWRTY29wZShpbml0Lm5hbWUpICE9PSAnbW9kdWxlJykgcmV0dXJuXG5cbiAgICAgIGNvbnN0IG5hbWVzcGFjZSA9IG5hbWVzcGFjZXMuZ2V0KGluaXQubmFtZSlcblxuICAgICAgZm9yIChsZXQgcHJvcGVydHkgb2YgaWQucHJvcGVydGllcykge1xuICAgICAgICBpZiAocHJvcGVydHkua2V5LnR5cGUgIT09ICdJZGVudGlmaWVyJykge1xuICAgICAgICAgIGNvbnRleHQucmVwb3J0KHtcbiAgICAgICAgICAgIG5vZGU6IHByb3BlcnR5LFxuICAgICAgICAgICAgbWVzc2FnZTogJ09ubHkgZGVzdHJ1Y3R1cmUgdG9wLWxldmVsIG5hbWVzLicsXG4gICAgICAgICAgfSlcbiAgICAgICAgfSBlbHNlIGlmICghbmFtZXNwYWNlLmhhcyhwcm9wZXJ0eS5rZXkubmFtZSkpIHtcbiAgICAgICAgICBjb250ZXh0LnJlcG9ydCh7XG4gICAgICAgICAgICBub2RlOiBwcm9wZXJ0eSxcbiAgICAgICAgICAgIG1lc3NhZ2U6IG1lc3NhZ2UocHJvcGVydHkua2V5LCBpbml0KSxcbiAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgfVxufVxuIl19