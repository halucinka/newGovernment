"use strict";

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

Object.defineProperty(exports, "__esModule", {
	value: true
});

exports.default = function (_ref) {
	var t = _ref.types;

	/**
  * Test if a VariableDeclaration's declarations contains any Patterns.
  */

	function variableDeclarationHasPattern(node) {
		var _iteratorNormalCompletion = true;
		var _didIteratorError = false;
		var _iteratorError = undefined;

		try {
			for (var _iterator = node.declarations[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
				var declar = _step.value;

				if (t.isPattern(declar.id)) {
					return true;
				}
			}
		} catch (err) {
			_didIteratorError = true;
			_iteratorError = err;
		} finally {
			try {
				if (!_iteratorNormalCompletion && _iterator.return) {
					_iterator.return();
				}
			} finally {
				if (_didIteratorError) {
					throw _iteratorError;
				}
			}
		}

		return false;
	}

	/**
  * Test if an ArrayPattern's elements contain any RestElements.
  */

	function hasRest(pattern) {
		var _iteratorNormalCompletion2 = true;
		var _didIteratorError2 = false;
		var _iteratorError2 = undefined;

		try {
			for (var _iterator2 = pattern.elements[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
				var elem = _step2.value;

				if (t.isRestElement(elem)) {
					return true;
				}
			}
		} catch (err) {
			_didIteratorError2 = true;
			_iteratorError2 = err;
		} finally {
			try {
				if (!_iteratorNormalCompletion2 && _iterator2.return) {
					_iterator2.return();
				}
			} finally {
				if (_didIteratorError2) {
					throw _iteratorError2;
				}
			}
		}

		return false;
	}

	var arrayUnpackVisitor = {
		ReferencedIdentifier: function ReferencedIdentifier(path, state) {
			if (state.bindings[path.node.name]) {
				state.deopt = true;
				path.stop();
			}
		}
	};

	var SymbolForGet = t.callExpression(t.identifier("Symbol.for"), [t.stringLiteral("get")]);

	var DestructuringTransformer = (function () {
		function DestructuringTransformer(opts) {
			_classCallCheck(this, DestructuringTransformer);

			this.blockHoist = opts.blockHoist;
			this.operator = opts.operator;
			this.arrays = {};
			this.nodes = opts.nodes || [];
			this.scope = opts.scope;
			this.file = opts.file;
			this.kind = opts.kind;
		}

		_createClass(DestructuringTransformer, [{
			key: "buildVariableAssignment",
			value: function buildVariableAssignment(id, init) {
				var op = this.operator;
				if (t.isMemberExpression(id)) op = "=";

				var node = undefined;

				if (op) {
					node = t.expressionStatement(t.assignmentExpression(op, id, init));
				} else {
					node = t.variableDeclaration(this.kind, [t.variableDeclarator(id, init)]);
				}

				node._blockHoist = this.blockHoist;

				return node;
			}
		}, {
			key: "buildVariableDeclaration",
			value: function buildVariableDeclaration(id, init) {
				var declar = t.variableDeclaration("var", [t.variableDeclarator(id, init)]);
				declar._blockHoist = this.blockHoist;
				return declar;
			}
		}, {
			key: "push",
			value: function push(id, init) {
				if (t.isObjectPattern(id)) {
					this.pushObjectPattern(id, init);
				} else if (t.isArrayPattern(id)) {
					this.pushArrayPattern(id, init);
				} else if (t.isAssignmentPattern(id)) {
					this.pushAssignmentPattern(id, init);
				} else {
					this.nodes.push(this.buildVariableAssignment(id, init));
				}
			}
		}, {
			key: "toArray",
			value: function toArray(node, count) {
				if (this.file.opts.loose || t.isIdentifier(node) && this.arrays[node.name]) {
					return node;
				} else {
					return this.scope.toArray(node, count);
				}
			}
		}, {
			key: "pushAssignmentPattern",
			value: function pushAssignmentPattern(pattern, valueRef) {
				// we need to assign the current value of the assignment to avoid evaluating
				// it more than once

				if (valueRef.object) {
					var objGetRef = t.memberExpression(valueRef.object, SymbolForGet, /* computed: */true);
					valueRef = t.conditionalExpression(objGetRef, t.callExpression(objGetRef, [DestructuringTransformer.symbolForGetArgument(valueRef.property, false)]), valueRef);
				}

				var tempValueRef = this.scope.generateUidIdentifierBasedOnNode(valueRef);

				var declar = t.variableDeclaration("var", [t.variableDeclarator(tempValueRef, valueRef)]);
				declar._blockHoist = this.blockHoist;
				this.nodes.push(declar);

				//

				var tempConditional = t.conditionalExpression(t.binaryExpression("===", tempValueRef, t.identifier("undefined")), pattern.right, tempValueRef);

				var left = pattern.left;
				if (t.isPattern(left)) {
					var tempValueDefault = t.expressionStatement(t.assignmentExpression("=", tempValueRef, tempConditional));
					tempValueDefault._blockHoist = this.blockHoist;

					this.nodes.push(tempValueDefault);
					this.push(left, tempValueRef);
				} else {
					this.nodes.push(this.buildVariableAssignment(left, tempConditional));
				}
			}
		}, {
			key: "pushObjectRest",
			value: function pushObjectRest(pattern, objRef, spreadProp, spreadPropIndex) {
				// get all the keys that appear in this object before the current spread

				var keys = [];

				for (var i = 0; i < pattern.properties.length; i++) {
					var prop = pattern.properties[i];

					// we've exceeded the index of the spread property to all properties to the
					// right need to be ignored
					if (i >= spreadPropIndex) break;

					// ignore other spread properties
					if (t.isRestProperty(prop)) continue;

					var key = prop.key;
					if (t.isIdentifier(key) && !prop.computed) key = t.stringLiteral(prop.key.name);
					keys.push(key);
				}

				keys = t.arrayExpression(keys);

				//

				var value = t.callExpression(this.file.addHelper("objectWithoutProperties"), [objRef, keys]);
				this.nodes.push(this.buildVariableAssignment(spreadProp.argument, value));
			}
		}, {
			key: "pushObjectProperty",
			value: function pushObjectProperty(prop, propRef) {
				if (t.isLiteral(prop.key)) prop.computed = true;

				var pattern = prop.value;
				var objRef = t.memberExpression(propRef, prop.key, prop.computed);

				if (t.isPattern(pattern)) {
					this.push(pattern, objRef);
				} else {
					var objGetRef = t.memberExpression(propRef, SymbolForGet, /* computed: */true);
					var fullObjRef = t.conditionalExpression(objGetRef, t.callExpression(objGetRef, [DestructuringTransformer.symbolForGetArgument(prop.key, prop.computed)]), objRef);

					this.nodes.push(this.buildVariableAssignment(pattern, fullObjRef));
				}
			}
		}, {
			key: "pushObjectPattern",
			value: function pushObjectPattern(pattern, objRef) {
				// https://github.com/babel/babel/issues/681

				if (!pattern.properties.length) {
					this.nodes.push(t.expressionStatement(t.callExpression(this.file.addHelper("objectDestructuringEmpty"), [objRef])));
				}

				// if we have more than one properties in this pattern and the objectRef is a
				// member expression then we need to assign it to a temporary variable so it's
				// only evaluated once

				if (pattern.properties.length > 1 && !this.scope.isStatic(objRef)) {
					var temp = this.scope.generateUidIdentifierBasedOnNode(objRef);

					var tempObjGetRef = t.memberExpression(objRef.object, SymbolForGet, /* computed: */true);
					var tempFullObjRef = t.conditionalExpression(tempObjGetRef, t.callExpression(tempObjGetRef, [DestructuringTransformer.symbolForGetArgument(objRef.property, false)]), objRef);

					this.nodes.push(this.buildVariableDeclaration(temp, tempFullObjRef));
					objRef = temp;
				}

				//

				for (var i = 0; i < pattern.properties.length; i++) {
					var prop = pattern.properties[i];
					if (t.isRestProperty(prop)) {
						this.pushObjectRest(pattern, objRef, prop, i);
					} else {
						if (objRef.object) {
							var objGetRef = t.memberExpression(objRef.object, SymbolForGet, /* computed: */true);
							var fullObjRef = t.conditionalExpression(objGetRef, t.callExpression(objGetRef, [DestructuringTransformer.symbolForGetArgument(objRef.property, false)]), objRef);

							this.pushObjectProperty(prop, fullObjRef);
						} else {
							this.pushObjectProperty(prop, objRef);
						}
					}
				}
			}
		}, {
			key: "canUnpackArrayPattern",
			value: function canUnpackArrayPattern(pattern, arr) {
				// not an array so there's no way we can deal with this
				if (!t.isArrayExpression(arr)) return false;

				// pattern has less elements than the array and doesn't have a rest so some
				// elements wont be evaluated
				if (pattern.elements.length > arr.elements.length) return;
				if (pattern.elements.length < arr.elements.length && !hasRest(pattern)) return false;

				var _iteratorNormalCompletion3 = true;
				var _didIteratorError3 = false;
				var _iteratorError3 = undefined;

				try {
					for (var _iterator3 = pattern.elements[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
						var elem = _step3.value;

						// deopt on holes
						if (!elem) return false;

						// deopt on member expressions as they may be included in the RHS
						if (t.isMemberExpression(elem)) return false;
					}
				} catch (err) {
					_didIteratorError3 = true;
					_iteratorError3 = err;
				} finally {
					try {
						if (!_iteratorNormalCompletion3 && _iterator3.return) {
							_iterator3.return();
						}
					} finally {
						if (_didIteratorError3) {
							throw _iteratorError3;
						}
					}
				}

				var _iteratorNormalCompletion4 = true;
				var _didIteratorError4 = false;
				var _iteratorError4 = undefined;

				try {
					for (var _iterator4 = arr.elements[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
						var elem = _step4.value;

						// deopt on spread elements
						if (t.isSpreadElement(elem)) return false;
					}

					// deopt on reference to left side identifiers
				} catch (err) {
					_didIteratorError4 = true;
					_iteratorError4 = err;
				} finally {
					try {
						if (!_iteratorNormalCompletion4 && _iterator4.return) {
							_iterator4.return();
						}
					} finally {
						if (_didIteratorError4) {
							throw _iteratorError4;
						}
					}
				}

				var bindings = t.getBindingIdentifiers(pattern);
				var state = { deopt: false, bindings: bindings };
				this.scope.traverse(arr, arrayUnpackVisitor, state);
				return !state.deopt;
			}
		}, {
			key: "pushUnpackedArrayPattern",
			value: function pushUnpackedArrayPattern(pattern, arr) {
				for (var i = 0; i < pattern.elements.length; i++) {
					var elem = pattern.elements[i];
					if (t.isRestElement(elem)) {
						this.push(elem.argument, t.arrayExpression(arr.elements.slice(i)));
					} else {
						this.push(elem, arr.elements[i]);
					}
				}
			}
		}, {
			key: "pushArrayPattern",
			value: function pushArrayPattern(pattern, arrayRef) {
				if (!pattern.elements) return;

				// optimise basic array destructuring of an array expression
				//
				// we can't do this to a pattern of unequal size to it's right hand
				// array expression as then there will be values that wont be evaluated
				//
				// eg: let [a, b] = [1, 2];

				if (this.canUnpackArrayPattern(pattern, arrayRef)) {
					return this.pushUnpackedArrayPattern(pattern, arrayRef);
				}

				// if we have a rest then we need all the elements so don't tell
				// `scope.toArray` to only get a certain amount

				var count = !hasRest(pattern) && pattern.elements.length;

				// so we need to ensure that the `arrayRef` is an array, `scope.toArray` will
				// return a locally bound identifier if it's been inferred to be an array,
				// otherwise it'll be a call to a helper that will ensure it's one

				var toArray = this.toArray(arrayRef, count);

				if (t.isIdentifier(toArray)) {
					// we've been given an identifier so it must have been inferred to be an
					// array
					arrayRef = toArray;
				} else {
					arrayRef = this.scope.generateUidIdentifierBasedOnNode(arrayRef);
					this.arrays[arrayRef.name] = true;
					this.nodes.push(this.buildVariableDeclaration(arrayRef, toArray));
				}

				//

				for (var i = 0; i < pattern.elements.length; i++) {
					var elem = pattern.elements[i];

					// hole
					if (!elem) continue;

					var elemRef = undefined;

					if (t.isRestElement(elem)) {
						elemRef = this.toArray(arrayRef);

						if (i > 0) {
							elemRef = t.callExpression(t.memberExpression(elemRef, t.identifier("slice")), [t.numericLiteral(i)]);
						}

						// set the element to the rest element argument since we've dealt with it
						// being a rest already
						elem = elem.argument;
					} else {
						elemRef = t.memberExpression(arrayRef, t.numericLiteral(i), true);
					}

					this.push(elem, elemRef);
				}
			}
		}, {
			key: "init",
			value: function init(pattern, ref) {
				// trying to destructure a value that we can't evaluate more than once so we
				// need to save it to a variable

				if (!t.isArrayExpression(ref) && !t.isMemberExpression(ref)) {
					var memo = this.scope.maybeGenerateMemoised(ref, true);
					if (memo) {
						this.nodes.push(this.buildVariableDeclaration(memo, ref));
						ref = memo;
					}
				}

				//

				this.push(pattern, ref);

				return this.nodes;
			}
		}], [{
			key: "symbolForGetArgument",
			value: function symbolForGetArgument(prop, computed) {
				if (t.isIdentifier(prop)) {
					if (computed) {
						return prop;
					} else {
						return t.stringLiteral(prop.name);
					}
				} else {
					return prop;
				}
			}
		}]);

		return DestructuringTransformer;
	})();

	return {
		visitor: {
			ForXStatement: function ForXStatement(path, file) {
				var node = path.node;
				var scope = path.scope;

				var left = node.left;

				if (t.isPattern(left)) {
					// for ({ length: k } in { abc: 3 });

					var temp = scope.generateUidIdentifier("ref");

					node.left = t.variableDeclaration("var", [t.variableDeclarator(temp)]);

					path.ensureBlock();

					node.body.body.unshift(t.variableDeclaration("var", [t.variableDeclarator(left, temp)]));

					return;
				}

				if (!t.isVariableDeclaration(left)) return;

				var pattern = left.declarations[0].id;
				if (!t.isPattern(pattern)) return;

				var key = scope.generateUidIdentifier("ref");
				node.left = t.variableDeclaration(left.kind, [t.variableDeclarator(key, null)]);

				var nodes = [];

				var destructuring = new DestructuringTransformer({
					kind: left.kind,
					file: file,
					scope: scope,
					nodes: nodes
				});

				destructuring.init(pattern, key);

				path.ensureBlock();

				var block = node.body;
				block.body = nodes.concat(block.body);
			},
			CatchClause: function CatchClause(_ref2, file) {
				var node = _ref2.node;
				var scope = _ref2.scope;

				var pattern = node.param;
				if (!t.isPattern(pattern)) return;

				var ref = scope.generateUidIdentifier("ref");
				node.param = ref;

				var nodes = [];

				var destructuring = new DestructuringTransformer({
					kind: "let",
					file: file,
					scope: scope,
					nodes: nodes
				});
				destructuring.init(pattern, ref);

				node.body.body = nodes.concat(node.body.body);
			},
			AssignmentExpression: function AssignmentExpression(path, file) {
				var node = path.node;
				var scope = path.scope;

				if (!t.isPattern(node.left)) return;

				var nodes = [];

				var destructuring = new DestructuringTransformer({
					operator: node.operator,
					file: file,
					scope: scope,
					nodes: nodes
				});

				var ref = undefined;
				if (path.isCompletionRecord() || !path.parentPath.isExpressionStatement()) {
					ref = scope.generateUidIdentifierBasedOnNode(node.right, "ref");

					nodes.push(t.variableDeclaration("var", [t.variableDeclarator(ref, node.right)]));

					if (t.isArrayExpression(node.right)) {
						destructuring.arrays[ref.name] = true;
					}
				}

				destructuring.init(node.left, ref || node.right);

				if (ref) {
					nodes.push(t.expressionStatement(ref));
				}

				path.replaceWithMultiple(nodes);
			},
			VariableDeclaration: function VariableDeclaration(path, file) {
				var node = path.node;
				var scope = path.scope;
				var parent = path.parent;

				if (t.isForXStatement(parent)) return;
				if (!parent || !path.container) return; // i don't know why this is necessary - TODO
				if (!variableDeclarationHasPattern(node)) return;

				var nodes = [];
				var declar = undefined;

				for (var i = 0; i < node.declarations.length; i++) {
					declar = node.declarations[i];

					var patternId = declar.init;
					var pattern = declar.id;

					var destructuring = new DestructuringTransformer({
						blockHoist: node._blockHoist,
						nodes: nodes,
						scope: scope,
						kind: node.kind,
						file: file
					});

					if (t.isPattern(pattern)) {
						destructuring.init(pattern, patternId);

						if (+i !== node.declarations.length - 1) {
							// we aren't the last declarator so let's just make the
							// last transformed node inherit from us
							t.inherits(nodes[nodes.length - 1], declar);
						}
					} else {
						nodes.push(t.inherits(destructuring.buildVariableAssignment(declar.id, declar.init), declar));
					}
				}

				path.replaceWithMultiple(nodes);
			}
		}
	};
};

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }